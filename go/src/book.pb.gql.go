// Code generated by protoc-gen-graphql-gateway. DO NOT EDIT.
// source: book.proto

/*
Package book is a reverse proxy.

It translates gRPC into GraphQL.
*/
package book

import (
	"context"

	"github.com/graphql-go/graphql"
	"github.com/grpc-custom/graphql-gateway/runtime"
	"github.com/grpc-custom/graphql-gateway/runtime/cache"
	"github.com/grpc-custom/graphql-gateway/runtime/errors"
	"github.com/grpc-custom/graphql-gateway/runtime/scalar"
	"golang.org/x/sync/singleflight"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
)

var (
	bookType = graphql.NewObject(graphql.ObjectConfig{
		Name: "Book",
		Fields: graphql.Fields{
			"isbn": &graphql.Field{
				Type: scalar.String,
			},
			"title": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	getBookIsbnType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetBookIsbn",
		Fields: graphql.Fields{
			"isbn": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	getBookStructType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetBookStruct",
		Fields: graphql.Fields{
			"book": &graphql.Field{
				Type: bookType,
			},
		},
	})
)

type bookServiceResolver struct {
	client BookServiceClient
	group  singleflight.Group
	c      cache.Cache
}

func newBookServiceResolver(client BookServiceClient) *bookServiceResolver {
	return &bookServiceResolver{
		client: client,
		group:  singleflight.Group{},
		c:      cache.New(100),
	}
}

func (r *bookServiceResolver) FieldGetBook() *graphql.Field {
	field := &graphql.Field{
		Name:        "/book.BookService/GetBook",
		Description: "",
		Type:        getBookStructType,
		Args: graphql.FieldConfigArgument{
			"isbn": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
		},
		Resolve: r.resolveGetBook,
	}
	return field
}

func (r *bookServiceResolver) resolveGetBook(p graphql.ResolveParams) (interface{}, error) {
	in := &GetBookIsbn{}
	valueIsbn, ok := p.Args["isbn"].(string)
	if !ok {
		valueIsbn = ""
	}
	in.Isbn = valueIsbn
	ctx := runtime.Context(p.Context)
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	result, err := r.client.GetBook(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return result, nil
}

type bookCreateServiceResolver struct {
	client BookCreateServiceClient
	group  singleflight.Group
	c      cache.Cache
}

func newBookCreateServiceResolver(client BookCreateServiceClient) *bookCreateServiceResolver {
	return &bookCreateServiceResolver{
		client: client,
		group:  singleflight.Group{},
		c:      cache.New(100),
	}
}

func (r *bookCreateServiceResolver) FieldCreateBook() *graphql.Field {
	field := &graphql.Field{
		Name:        "/book.BookCreateService/CreateBook",
		Description: "",
		Type:        getBookIsbnType,
		Args: graphql.FieldConfigArgument{
			"book": &graphql.ArgumentConfig{
				Type: bookType,
			},
		},
		Resolve: r.resolveCreateBook,
	}
	return field
}

func (r *bookCreateServiceResolver) resolveCreateBook(p graphql.ResolveParams) (interface{}, error) {
	in := &GetBookStruct{}
	valueBook, ok := p.Args["book"].(*Book)
	if !ok {
		valueBook = nil
	}
	in.Book = valueBook
	ctx := runtime.Context(p.Context)
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	result, err := r.client.CreateBook(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return result, nil
}

func RegisterBookServiceFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return
	}
	defer func() {
		if err != nil {
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
		}()
	}()
	return RegisterBookServiceHandler(mux, conn)
}

func RegisterBookServiceHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterBookServiceHandlerClient(mux, NewBookServiceClient(conn))
}

func RegisterBookServiceHandlerClient(mux *runtime.ServeMux, client BookServiceClient) error {
	svc := newBookServiceResolver(client)
	// gRPC /book.BookService/GetBook
	mux.AddQuery("getBook", svc.FieldGetBook())
	return nil
}

func RegisterBookCreateServiceFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return
	}
	defer func() {
		if err != nil {
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
		}()
	}()
	return RegisterBookCreateServiceHandler(mux, conn)
}

func RegisterBookCreateServiceHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterBookCreateServiceHandlerClient(mux, NewBookCreateServiceClient(conn))
}

func RegisterBookCreateServiceHandlerClient(mux *runtime.ServeMux, client BookCreateServiceClient) error {
	svc := newBookCreateServiceResolver(client)
	// gRPC /book.BookCreateService/CreateBook
	mux.AddMutation("createBook", svc.FieldCreateBook())
	return nil
}
