// Code generated by protoc-gen-graphql-gateway. DO NOT EDIT.
// source: user.proto

/*
Package user is a reverse proxy.

It translates gRPC into GraphQL.
*/
package user

import (
	"context"

	"github.com/graphql-go/graphql"
	"github.com/grpc-custom/graphql-gateway/runtime"
	"github.com/grpc-custom/graphql-gateway/runtime/cache"
	"github.com/grpc-custom/graphql-gateway/runtime/errors"
	"github.com/grpc-custom/graphql-gateway/runtime/scalar"
	"golang.org/x/sync/singleflight"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
)

var (
	userType = graphql.NewObject(graphql.ObjectConfig{
		Name: "User",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: scalar.Int32,
			},
			"name": &graphql.Field{
				Type: scalar.String,
			},
			"email": &graphql.Field{
				Type: scalar.String,
			},
			"photoUrl": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	getUserRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetUserRequest",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: scalar.Int32,
			},
		},
	})

	getUserResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetUserResponse",
		Fields: graphql.Fields{
			"user": &graphql.Field{
				Type: userType,
			},
		},
	})

	getUserListRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetUserListRequest",
		Fields: graphql.Fields{
			"name": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	getUserListResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "GetUserListResponse",
		Fields: graphql.Fields{
			"userList": &graphql.Field{
				Type: graphql.NewList(userType),
			},
		},
	})

	createUserRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "CreateUserRequest",
		Fields: graphql.Fields{
			"name": &graphql.Field{
				Type: scalar.String,
			},
			"email": &graphql.Field{
				Type: scalar.String,
			},
			"photoUrl": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	createUserResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "CreateUserResponse",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: scalar.Int32,
			},
		},
	})

	updateUserRequestType = graphql.NewObject(graphql.ObjectConfig{
		Name: "UpdateUserRequest",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: scalar.Int32,
			},
			"name": &graphql.Field{
				Type: scalar.String,
			},
			"email": &graphql.Field{
				Type: scalar.String,
			},
			"photoUrl": &graphql.Field{
				Type: scalar.String,
			},
		},
	})

	updateUserResponseType = graphql.NewObject(graphql.ObjectConfig{
		Name: "UpdateUserResponse",
		Fields: graphql.Fields{
			"id": &graphql.Field{
				Type: scalar.Int32,
			},
		},
	})
)

type userServiceResolver struct {
	client UserServiceClient
	group  singleflight.Group
	c      cache.Cache
}

func newUserServiceResolver(client UserServiceClient) *userServiceResolver {
	return &userServiceResolver{
		client: client,
		group:  singleflight.Group{},
		c:      cache.New(100),
	}
}

func (r *userServiceResolver) FieldGetUser() *graphql.Field {
	field := &graphql.Field{
		Name:        "/user.UserService/GetUser",
		Description: "",
		Type:        getUserResponseType,
		Args: graphql.FieldConfigArgument{
			"id": &graphql.ArgumentConfig{
				Type: scalar.Int32,
			},
		},
		Resolve: r.resolveGetUser,
	}
	return field
}

func (r *userServiceResolver) resolveGetUser(p graphql.ResolveParams) (interface{}, error) {
	in := &GetUserRequest{}
	valueId, ok := p.Args["id"].(int32)
	if !ok {
		valueId = 0
	}
	in.Id = valueId
	ctx := runtime.Context(p.Context)
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	result, err := r.client.GetUser(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return result, nil
}

func (r *userServiceResolver) FieldGetUserList() *graphql.Field {
	field := &graphql.Field{
		Name:        "/user.UserService/GetUserList",
		Description: "",
		Type:        getUserListResponseType,
		Args: graphql.FieldConfigArgument{
			"name": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
		},
		Resolve: r.resolveGetUserList,
	}
	return field
}

func (r *userServiceResolver) resolveGetUserList(p graphql.ResolveParams) (interface{}, error) {
	in := &GetUserListRequest{}
	valueName, ok := p.Args["name"].(string)
	if !ok {
		valueName = ""
	}
	in.Name = valueName
	ctx := runtime.Context(p.Context)
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	result, err := r.client.GetUserList(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return result, nil
}

func (r *userServiceResolver) FieldCreateUser() *graphql.Field {
	field := &graphql.Field{
		Name:        "/user.UserService/CreateUser",
		Description: "",
		Type:        createUserResponseType,
		Args: graphql.FieldConfigArgument{
			"name": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
			"email": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
			"photoUrl": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
		},
		Resolve: r.resolveCreateUser,
	}
	return field
}

func (r *userServiceResolver) resolveCreateUser(p graphql.ResolveParams) (interface{}, error) {
	in := &CreateUserRequest{}
	valueName, ok := p.Args["name"].(string)
	if !ok {
		valueName = ""
	}
	in.Name = valueName
	valueEmail, ok := p.Args["email"].(string)
	if !ok {
		valueEmail = ""
	}
	in.Email = valueEmail
	valuePhotoUrl, ok := p.Args["photoUrl"].(string)
	if !ok {
		valuePhotoUrl = ""
	}
	in.PhotoUrl = valuePhotoUrl
	ctx := runtime.Context(p.Context)
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	result, err := r.client.CreateUser(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return result, nil
}

func (r *userServiceResolver) FieldUpdateUser() *graphql.Field {
	field := &graphql.Field{
		Name:        "/user.UserService/UpdateUser",
		Description: "",
		Type:        updateUserResponseType,
		Args: graphql.FieldConfigArgument{
			"id": &graphql.ArgumentConfig{
				Type: scalar.Int32,
			},
			"name": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
			"email": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
			"photoUrl": &graphql.ArgumentConfig{
				Type: scalar.String,
			},
		},
		Resolve: r.resolveUpdateUser,
	}
	return field
}

func (r *userServiceResolver) resolveUpdateUser(p graphql.ResolveParams) (interface{}, error) {
	in := &UpdateUserRequest{}
	valueId, ok := p.Args["id"].(int32)
	if !ok {
		valueId = 0
	}
	in.Id = valueId
	valueName, ok := p.Args["name"].(string)
	if !ok {
		valueName = ""
	}
	in.Name = valueName
	valueEmail, ok := p.Args["email"].(string)
	if !ok {
		valueEmail = ""
	}
	in.Email = valueEmail
	valuePhotoUrl, ok := p.Args["photoUrl"].(string)
	if !ok {
		valuePhotoUrl = ""
	}
	in.PhotoUrl = valuePhotoUrl
	ctx := runtime.Context(p.Context)
	if timeout := runtime.GrpcTimeout(ctx); timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}
	result, err := r.client.UpdateUser(ctx, in)
	if err != nil {
		return nil, errors.ToGraphQLError(err)
	}
	return result, nil
}

func RegisterUserServiceFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return
	}
	defer func() {
		if err != nil {
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if e := conn.Close(); e != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, e)
			}
		}()
	}()
	return RegisterUserServiceHandler(mux, conn)
}

func RegisterUserServiceHandler(mux *runtime.ServeMux, conn *grpc.ClientConn) error {
	return RegisterUserServiceHandlerClient(mux, NewUserServiceClient(conn))
}

func RegisterUserServiceHandlerClient(mux *runtime.ServeMux, client UserServiceClient) error {
	svc := newUserServiceResolver(client)
	// gRPC /user.UserService/GetUser
	mux.AddQuery("getUser", svc.FieldGetUser())
	// gRPC /user.UserService/GetUserList
	mux.AddQuery("getUserList", svc.FieldGetUserList())
	// gRPC /user.UserService/CreateUser
	mux.AddMutation("createUser", svc.FieldCreateUser())
	// gRPC /user.UserService/UpdateUser
	mux.AddMutation("updateUser", svc.FieldUpdateUser())
	return nil
}
